# 洛谷2019夏令营 入门组 听课笔记

## Class 1-5

划水

## Class 6

### 1.模运算

* 题目：[P1226 模板 快速幂与整数取余](https://www.luogu.org/problem/P1226)

> 参考资料：[模运算总结](https://blog.sengxian.com/algorithms/mod-world)

  $$(a+b)\mod\;n=(a\mod\;n+b\mod\;n)\mod\;n$$

  $$(a\times\;b)\mod\;n=((a\mod\;n)\times\;(b\mod\;n))\mod\;n$$

### 2.快速幂

> 参考资料：1. [快速幂详解](https://www.cnblogs.com/sun-of-Ice/p/9330352.html)
> 2.[OI Wiki 快速幂](https://oi-wiki.org/math/quick-pow/)

方法：

1. 如果 n 能被 2 整除，可以先计算一半，得到$a^\frac{n}{2}$的值，再把这个值平方得出结果。这样做虽然有优化，但优化的程度很小，仍是线性的复杂度。

2. 再比如，如果我们能找到$2^k=n$，那我们就能把原来的运算优化成

$$a^{2^{2^{2^{\dots}}}}$$
只需要 k 次运算就可以完成，效率大大提升。可惜的是，这种条件显然太苛刻了，适用范围很小。不过这给了我们一种思路，虽然我们很难找到$2k=n$，但我们能够找到$2^{k_1}+2^{k_2}+2^{k_3}+\dots+2^{k_m}=n$。这样，我们可以通过递推，在很短的时间内求出各个项的值。

比如，2 进制数 1001，它的值可以表示为 10 进制的$1×2^3+0×2^2+0×2^1+1×2^0$，即 9。这完美地符合了上面的要求。可以通过 2 进制来把 n 转化成$2^{k_m}$的序列之和，而 2 进制中第 i 位（从右边开始计数，值为 1 或是 0）则标记了对应的$2^{i−1}$是否存在于序列之中。譬如，13 为二进制的 1101，他可以表示为$2^3+2^2+2^0$，其中由于第二位为 0，$2^1$项被舍去。

如此一来，我们只需要计算$a、a^2、a^4、a^8、\dots、a^{2^{k_m}}$的值（这个序列中的项不一定都存在，由 n 的二进制决定）并把它们乘起来即可完成整个幂运算。借助位运算的操作，可以很方便地实现这一算法，其复杂度为$O(\log n)$。

* 技巧：$n\&1\Leftrightarrow\;n\%2==1$ 快速奇偶判断

* & 的运算性质：有 0 出 0

代码实现（来自 OI Wiki）

```C
//递归方法
long long binpow(long long a, long long b) {
  if (b == 0) return 1;
  long long res = binpow(a, b / 2);
  if (b % 2)
    return res * res * a;
  else
    return res * res;
}
```

